{"version":3,"sources":["../../src/h264/h264_slice_parser.js"],"names":["Util","require","ExpGolomb","NALU","assert","PPSParser","MAX_MMCO_COUNT","encodeType","TOP_FIELD","BOTTOM_FIELD","FRAME","AUTO","Types","MMCOOpcode","H264SliceParser","nalu","sps_table","pps_table","sei","rbsp","ebsp2rbsp","slice","gb","nal","skipBits","skipUEG","type","slice_type","readUEG","slice_string","getFrameTypeString","pps_id","pps","sps","sps_id","pic_num","frame_num","readUN","log2_max_frame_num","max_pic_num","field_pic_flag","encode_type","frame_mbs_only_flag","readBoolean","bottom_field_flag","mb_adaptive_frame_field_flag","console","error","key_frame","isKeyframe","idr_pic_id","recovery_point","recovery_frame_cnt","max_num_ref_frames","ref_count","I","poc","lsb","log2_max_poc_lsb","delta_bottom","pic_order_present_flag","readSEG","delta_pic_order_always_zero_flag","delta","got_reset","nri","_scanMMCOReset","SI","max","num_ref_idx_active_override_flag","B","chroma_format_idc","list","i","luma_weight0","luma_weight1","j","chroma_weight0","chroma_weight1","ref_pic_list_reordering_flag_l0_or_11","reordering_of_pic_nums_idc","bitsAvailable","_readRefPicListReorderingi","redundant_pic_cnt_present_flag","skipBit","lct","_parseRefCount","_readRefPicListReordering","weighted_pred_flag","P","SP","weighted_bipred_idc","_skipPredWeightTable","h","b","opcode","MMCO_LONG","MMCO_END","MMCO_RESET","MMCO_SHORT2LONG","id","_parseSliceHeader","exports","module"],"mappings":"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","file":"h264_slice_parser.js","sourcesContent":["/**\r\n * Created by Luky on 2017/8/2.\r\n */\r\n\r\nconst Util=require('./h264_util');\r\nconst ExpGolomb=require('./golomb');\r\nconst NALU=require('./h264_nalu_parser');\r\nconst assert=require('assert');\r\nconst PPSParser=require('./h264_pps_parser');\r\nconst MAX_MMCO_COUNT=66;\r\n\r\nconst encodeType={\r\n    TOP_FIELD:1,\r\n    BOTTOM_FIELD:2,\r\n    FRAME:3,\r\n    AUTO:4\r\n};\r\n\r\nconst Types={\r\n    'P':0,\r\n    'B':1,\r\n    'I':2,\r\n    'SP':3,\r\n    'SI':4,\r\n    'P_ONLY':5,\r\n    'B_ONLY':6,\r\n    'I_ONLY':7,\r\n    'SP_ONLY':8,\r\n    'SI_ONLY':9\r\n};\r\n\r\n/**\r\n * Memory management control operation opcode.\r\n */\r\nconst MMCOOpcode ={\r\n    'MMCO_END' :0,\r\n    'MMCO_SHORT2UNUSED':1,\r\n    'MMCO_LONG2UNUSED':2,\r\n    'MMCO_SHORT2LONG':3,\r\n    'MMCO_SET_MAX_LONG':4,\r\n    'MMCO_RESET':5,\r\n    'MMCO_LONG':6\r\n} ;\r\n\r\nclass H264SliceParser{\r\n    static get EncodeTypes(){\r\n        return encodeType;\r\n    }\r\n\r\n    static _parseSliceHeader(nalu,sps_table,pps_table,sei){\r\n        let rbsp = Util.ebsp2rbsp(nalu.slice(0,60));//不对所有内容解码\r\n        let gb = new ExpGolomb(rbsp);\r\n        let nal=new NALU(nalu);\r\n        gb.skipBits(8);\r\n        let slice={};\r\n        gb.skipUEG();//first_mb_in_slice当前slice中包含的第一个宏块在整帧中的位置\r\n        let type=slice.slice_type=gb.readUEG();//当前slice的类型\r\n        if(type>=5)type-=5;\r\n        slice.slice_string=H264SliceParser.getFrameTypeString(slice.slice_type);\r\n        slice.pps_id=gb.readUEG();//当前slice所依赖的pps的id\r\n\r\n        let pps=/*slice.pps = */pps_table[slice.pps_id];\r\n        let sps=/*slice.sps = */sps_table[pps.sps_id];\r\n        slice.sps_id=pps.sps_id;\r\n\r\n        slice.pic_num=slice.frame_num = gb.readUN(sps.log2_max_frame_num); // was u(v)\r\n        slice.max_pic_num=1<<sps.log2_max_frame_num;//frame_num能达到的最大值，最大值后变成0\r\n        slice.field_pic_flag=false;\r\n        slice.encode_type=encodeType.FRAME;\r\n        if(!sps.frame_mbs_only_flag)//全部是帧\r\n        {\r\n            //场编码标识位。当该标识位为1时表示当前slice按照场进行编码；\r\n            //该标识位为0时表示当前slice是帧或者帧场混合模式\r\n            slice.field_pic_flag = gb.readBoolean();\r\n            if( slice.field_pic_flag )\r\n            {\r\n                slice.max_pic_num*=2;\r\n                slice.pic_num=2*slice.pic_num+1;//场模式下，当前总是+1，另外个总是+0\r\n                slice.bottom_field_flag = gb.readBoolean();//底场标识位。该标志位为1表示当前slice是某一帧的底场；为0表示当前slice为某一帧的顶场\r\n                sps.encode_type=slice.bottom_field_flag?encodeType.BOTTOM_FIELD:encodeType.TOP_FIELD;\r\n            }\r\n            else if(sps.mb_adaptive_frame_field_flag){\r\n                console.error('帧场自适应编码方式不适用');\r\n                //sps.encode_type=encodeType.AUTO;\r\n            }\r\n        }\r\n\r\n        slice.key_frame=false;\r\n        if( nal.isKeyframe)\r\n        {\r\n            slice.key_frame=true;\r\n            slice.idr_pic_id = gb.readUEG();//表示IDR帧的序号。某一个IDR帧所属的所有slice，其idr_pic_id应保持一致。该值的取值范围为[0,65535]\r\n        }\r\n        sei=sei||{};\r\n        if('recovery_point' in sei&&sei.recovery_point.recovery_frame_cnt >= 0){\r\n            slice.key_frame=true;\r\n        }\r\n\r\n        if(sps.max_num_ref_frames<=1&&pps.ref_count[0]<=1&&type===Types.I){\r\n            slice.key_frame=true;\r\n        }\r\n\r\n        slice.poc={};\r\n        if( sps.poc.type === 0 )\r\n        {\r\n            slice.poc.lsb = gb.readUN(sps.poc.log2_max_poc_lsb); // was u(v)\r\n            slice.poc.delta_bottom=0;\r\n            if( pps.pic_order_present_flag && !slice.field_pic_flag )\r\n            {\r\n                slice.poc.delta_bottom = gb.readSEG();\r\n            }\r\n        }\r\n        if( sps.poc.type === 1 && !sps.delta_pic_order_always_zero_flag )\r\n        {\r\n            slice.poc.delta= [gb.readSEG()];\r\n            if( pps.pic_order_present_flag && !slice.field_pic_flag )\r\n            {\r\n                slice.poc.delta[ 1 ] = gb.readSEG();\r\n            }\r\n        }\r\n\r\n        slice.got_reset=false;\r\n        if(nal.nri>0&&!nal.isKeyframe){\r\n            slice.got_reset=H264SliceParser._scanMMCOReset(slice,sps,pps,gb)===1;\r\n        }\r\n        return slice;\r\n        /*\r\n\r\n        return [sh,gb];*/\r\n    }\r\n\r\n    static _parseRefCount(slice,pps,gb){\r\n        slice.ref_count=[pps.ref_count[0],pps.ref_count[1]];\r\n        let type=slice.slice_type;\r\n        if(type>=5)type-=5;\r\n        if(type!==Types.I&&type!==Types.SI)\r\n        {\r\n            let max=[];\r\n            max[0]=max[1]=(slice.encode_type>=encodeType.FRAME?15:31);\r\n            let num_ref_idx_active_override_flag = gb.readBoolean();\r\n            if(num_ref_idx_active_override_flag )\r\n            {\r\n                slice.ref_count[0]= gb.readUEG()+1;//num_ref_idx_l0_active_minus1\r\n                if(type===Types.B)\r\n                    slice.ref_count[1]= gb.readUEG()+1;//num_ref_idx_l1_active_minus1\r\n                else slice.ref_count[1]=1;\r\n            }\r\n            if (slice.ref_count[0] - 1 > max[0] || slice.ref_count[1] - 1 > max[1]) {\r\n                console.error(`reference overflow ${slice.ref_count[0] - 1} > ${max[0]} or ${slice.ref_count[1] - 1} > ${max[1]}`);\r\n                slice.ref_count[0] = slice.ref_count[1] = 0;\r\n                return -1;\r\n            }\r\n            return 0;\r\n        }\r\n        slice.ref_count[0]=slice.ref_count[1]=0;\r\n        return 0;\r\n    }\r\n\r\n    static _skipPredWeightTable(slice,sps,gb){\r\n        gb.skipUEG();\r\n        let chroma_format_idc=sps.chroma_format_idc;\r\n        if (chroma_format_idc>0)gb.skipUEG();\r\n\r\n        for (let list = 0; list < 2; list++) {\r\n            for (let i = 0; i < slice.ref_count[list]; i++) {\r\n                if (gb.readBoolean()) {\r\n                    let luma_weight0=gb.readSEG();\r\n                    let luma_weight1=gb.readSEG();\r\n                    if (luma_weight0>127||luma_weight0<-128\r\n                        ||luma_weight1>127||luma_weight1<-128)\r\n                        return -1;\r\n                }\r\n\r\n                if (chroma_format_idc>0) {\r\n                    if (gb.readBoolean()) {\r\n                        for (let j = 0; j < 2; j++) {\r\n                            let chroma_weight0= gb.readSEG();\r\n                            let chroma_weight1= gb.readSEG();\r\n                            if (chroma_weight0>127||chroma_weight0<-128\r\n                                ||chroma_weight1>127||chroma_weight1<-128)\r\n                                return -1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if ( slice.slice_type!==Types.B)\r\n                break;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    static isSliceB(slice){\r\n        return slice.slice%5===Types.B;\r\n    }\r\n\r\n    static _readRefPicListReorderingi(slice,gb){\r\n        let ref_pic_list_reordering_flag_l0_or_11 = gb.readBoolean();\r\n\r\n        if( ref_pic_list_reordering_flag_l0_or_11)\r\n        {\r\n            let reordering_of_pic_nums_idc;\r\n            do\r\n            {\r\n                if((reordering_of_pic_nums_idc = gb.readUEG())>3){\r\n                    console.error(`illegal reordering_of_pic_nums_idc ${reordering_of_pic_nums_idc}`);\r\n                    return -1;\r\n                }\r\n                gb.skipUEG();\r\n            } while(reordering_of_pic_nums_idc !== 3 && gb.bitsAvailable>0);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    static _readRefPicListReordering(slice,gb){\r\n        let type=slice.slice_type;\r\n        if(type>=5)type-=5;\r\n        if(type!==Types.I&&type!==Types.SI)\r\n            H264SliceParser._readRefPicListReorderingi(slice,gb);\r\n        if(type===Types.B)\r\n            H264SliceParser._readRefPicListReorderingi(slice,gb);\r\n    }\r\n\r\n    static _scanMMCOReset(slice,sps,pps,gb){\r\n        if( pps.redundant_pic_cnt_present_flag )\r\n            gb.skipUEG();//redundant_pic_cnt\r\n        let type=slice.slice_type;\r\n        if(type>=5)type-=5;\r\n        if( type===Types.B)\r\n            gb.skipBit();//direct_spatial_mv_pred_flag\r\n\r\n        let lct=H264SliceParser._parseRefCount(slice,pps,gb);\r\n        if(lct<0) return false;\r\n        H264SliceParser._readRefPicListReordering(slice,gb);\r\n\r\n        if( ( pps.weighted_pred_flag &&(type===Types.P||type===Types.SP))\r\n            ||( pps.weighted_bipred_idc === 1 && type===Types.B )  )\r\n        {\r\n            H264SliceParser._skipPredWeightTable(h, b);\r\n        }\r\n\r\n        if (!gb.readBoolean()) { // adaptive_ref_pic_marking_mode_flag\r\n            return 0;\r\n        }\r\n\r\n        for (let i = 0; i < MAX_MMCO_COUNT; i++) {\r\n            let opcode = gb.readUEG();\r\n            //memory_management_control_operation\r\n            if (opcode > MMCOOpcode.MMCO_LONG) {\r\n                console.error(`illegal memory management control operation ${opcode}`);\r\n                return -1;\r\n            }\r\n            if (opcode === MMCOOpcode.MMCO_END)\r\n                return 0;\r\n            else if (opcode === MMCOOpcode.MMCO_RESET)\r\n                return 1;\r\n            gb.readUEG();\r\n            if (opcode === MMCOOpcode.MMCO_SHORT2LONG) gb.readUEG();\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    static getFrameTypeString(id) {\r\n        switch (id) {\r\n            case 0:\r\n                return 'P';\r\n            case 1:\r\n                return 'B';\r\n            case 2:\r\n                return 'I';\r\n            case 3:\r\n                return 'SP';\r\n            case 4:\r\n                return 'SI';\r\n            case 5:\r\n                return 'P_ONLY';\r\n            case 6:\r\n                return 'B_ONLY';\r\n            case 7:\r\n                return 'I_ONLY';\r\n            case 8:\r\n                return 'SP_ONLY';\r\n            case 9:\r\n                return 'SI_ONLY';\r\n            default:\r\n                return 'Unknown';\r\n        }\r\n    }\r\n\r\n    static TYPES(){\r\n        return Types;\r\n    }\r\n\r\n    static parseSlice(nalu,sps_table,pps_table,sei){\r\n        let slice=H264SliceParser._parseSliceHeader(nalu,sps_table,pps_table,sei);\r\n\r\n        //数据部分不解析\r\n/*        if(gb.bitsAvailable>0){\r\n            gb.skipBits(1);// CABAC-specific: skip alignment bits, if there are any\r\n        }\r\n        slice.sliceStart=gb._index;\r\n        slice.sliceEnd=gb.bitsAvailable;\r\n\r\n        // FIXME should read or skip data\r\n        //slice_data( ); /!* all categories of slice_data( ) syntax *!/\r\n        H264SliceParser._skipRBSPSliceTrailingBits(gb,slice.pps);*/\r\n        return slice;\r\n    }\r\n/*\r\n\r\n    static _skipRBSPSliceTrailingBits(gb,pps){\r\n        PPSParser.skipRBSPTrailingBits(gb);\r\n        if( pps.entropy_coding_mode_flag )\r\n        {\r\n            while( gb.bitsAvailable>0)\r\n            {\r\n                assert.ok(0===gb.readUN(16)); // equal to 0x0000\r\n            }\r\n        }\r\n    }\r\n*/\r\n}\r\n\r\nexports=module.exports=H264SliceParser;"]}