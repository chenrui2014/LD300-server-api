{"version":3,"sources":["../../src/h264/h264_sei_parser.js"],"names":["Util","require","ExpGolomb","SEI_type","BUFFERING_PERIOD","PIC_TIMING","USER_DATA_REGISTERED","USER_DATA_UNREGISTERED","RECOVERY_POINT","FRAME_PACKING","DISPLAY_ORIENTATION","GREEN_METADATA","SEIParser","nalu","rbsp","ebsp2rbsp","gb","skipByte","ret","bitsAvailable","readUN","type","size","next","readUByte","console","error","index","_decodeRecoveryPoint","skipBits","alignToByte","ssi","recovery_point","recovery_frame_cnt","readUEG","val","sei","exports","module"],"mappings":";;;;;;AAAA;;;;AAIA,IAAMA,OAAKC,QAAQ,aAAR,CAAX;AACA,IAAMC,YAAUD,QAAQ,UAAR,CAAhB;;AAEA,IAAME,WAAS;AACXC,sBAAkB,CADP,EACY;AACvBC,gBAAY,CAFD,EAEM;AACjBC,0BAAsB,CAHX,EAGgB;AAC3BC,4BAAwB,CAJb,EAIkB;AAC7BC,oBAAgB,CALL,EAKU;AACrBC,mBAAe,EANJ,EAMS;AACpBC,yBAAqB,EAPV,EAOe;AAC1BC,oBAAgB,EARL,CAQU;AARV,CAAf;;IAWMC,S;;;;;;;iCAKcC,I,EAAK;AACjB,gBAAIC,OAAOd,KAAKe,SAAL,CAAeF,IAAf,CAAX,CADiB,CACe;AAChC,gBAAIG,KAAK,IAAId,SAAJ,CAAcY,IAAd,CAAT;AACAE,eAAGC,QAAH;AACA,gBAAIC,MAAI,EAAR;AACA,mBAAOF,GAAGG,aAAH,GAAmB,EAAnB,IAAyBH,GAAGI,MAAH,CAAU,EAAV,EAAa,KAAb,IAAoB,CAApD,EAAuD;AACnD,oBAAIC,OAAO,CAAX;AACA,oBAAIC,OAAO,CAAX;AACA,oBAAIC,OAAK,CAAT;;AAEA,mBAAG;AACC,wBAAIP,GAAGG,aAAH,GAAmB,CAAvB,EACI,OAAOD,GAAP;AACJG,4BAAQL,GAAGI,MAAH,CAAU,CAAV,EAAY,KAAZ,CAAR;AACH,iBAJD,QAISJ,GAAGQ,SAAH,OAAmB,IAJ5B;;AAMA,mBAAG;AACC,wBAAIR,GAAGG,aAAH,GAAmB,CAAvB,EACI,OAAOD,GAAP;AACJI,4BAAQN,GAAGI,MAAH,CAAU,CAAV,EAAY,KAAZ,CAAR;AACH,iBAJD,QAISJ,GAAGQ,SAAH,OAAmB,IAJ5B;;AAMA,oBAAIF,OAAON,GAAGG,aAAH,GAAkB,CAA7B,EAAgC;AAC5BM,4BAAQC,KAAR,eAA0BL,IAA1B,cAAuC,IAAEC,IAAzC,sBAA8DN,GAAGG,aAAjE;AACA,2BAAOD,GAAP;AACH;AACDK,uBAAOP,GAAGW,KAAH,GAAW,IAAIL,IAAtB;;AAEA,oBAAGD,SAAOlB,SAASK,cAAnB,EAAkC;AAC9BI,8BAAUgB,oBAAV,CAA+BV,GAA/B,EAAmCF,EAAnC;AACAA,uBAAGa,QAAH,CAAYN,OAAKP,GAAGW,KAApB;AACH,iBAHD,MAII;AACAX,uBAAGa,QAAH,CAAY,IAAEP,IAAd;AACH;AACD;AACAN,mBAAGc,WAAH;AACH;;AAED,mBAAOZ,GAAP;AACH;;;6CAE2Ba,G,EAAIf,E,EAAG;AAC/Be,gBAAIC,cAAJ,GAAmB,EAACC,oBAAmBjB,GAAGkB,OAAH,EAApB,EAAnB;AACAlB,eAAGa,QAAH,CAAY,CAAZ;AACA,mBAAOM,GAAP;AACH;;;iCAEeC,G,EAAI;AAChBA,gBAAIJ,cAAJ,GAAmB,EAACC,oBAAmB,CAApB,EAAnB;AACH;;;4BArDD;AACI,mBAAO9B,QAAP;AACH;;;;;;AAsDLkC,UAAQC,OAAOD,OAAP,GAAezB,SAAvB","file":"h264_sei_parser.js","sourcesContent":["/**\r\n * Created by Luky on 2017/8/7.\r\n */\r\n\r\nconst Util=require('./h264_util');\r\nconst ExpGolomb=require('./golomb');\r\n\r\nconst SEI_type={\r\n    BUFFERING_PERIOD: 0,   ///< buffering period (H.264, D.1.1)\r\n    PIC_TIMING: 1,   ///< picture timing\r\n    USER_DATA_REGISTERED: 4,   ///< registered user data as specified by Rec. ITU-T T.35\r\n    USER_DATA_UNREGISTERED: 5,   ///< unregistered user data\r\n    RECOVERY_POINT: 6,   ///< recovery point (frame # to decoder sync)\r\n    FRAME_PACKING: 45,  ///< frame packing arrangement\r\n    DISPLAY_ORIENTATION: 47,  ///< display orientation\r\n    GREEN_METADATA: 56   ///< GreenMPEG information\r\n};\r\n\r\nclass SEIParser{\r\n    static get TYTES()\r\n    {\r\n        return SEI_type;\r\n    }\r\n    static parseSEI(nalu){\r\n        let rbsp = Util.ebsp2rbsp(nalu);//不对所有内容解码\r\n        let gb = new ExpGolomb(rbsp);\r\n        gb.skipByte();\r\n        let ret={};\r\n        while (gb.bitsAvailable > 16 && gb.readUN(16,false)>0) {\r\n            let type = 0;\r\n            let size = 0;\r\n            let next=0;\r\n\r\n            do {\r\n                if (gb.bitsAvailable < 8)\r\n                    return ret;\r\n                type += gb.readUN(8,false);\r\n            } while (gb.readUByte() === 0xff);\r\n\r\n            do {\r\n                if (gb.bitsAvailable < 8)\r\n                    return ret;\r\n                size += gb.readUN(8,false);\r\n            } while (gb.readUByte() === 0xff);\r\n\r\n            if (size > gb.bitsAvailable/ 8) {\r\n                console.error(`SEI type ${type} size ${8*size} truncated at ${gb.bitsAvailable}`);\r\n                return ret;\r\n            }\r\n            next = gb.index + 8 * size;\r\n\r\n            if(type===SEI_type.RECOVERY_POINT){\r\n                SEIParser._decodeRecoveryPoint(ret,gb);\r\n                gb.skipBits(next-gb.index);\r\n            }\r\n            else{\r\n                gb.skipBits(8*size);\r\n            }\r\n            // FIXME check bits here\r\n            gb.alignToByte();\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    static _decodeRecoveryPoint(ssi,gb){\r\n        ssi.recovery_point={recovery_frame_cnt:gb.readUEG()};\r\n        gb.skipBits(4);\r\n        return val;\r\n    }\r\n\r\n    static resetSEI(sei){\r\n        sei.recovery_point={recovery_frame_cnt:1};\r\n    }\r\n}\r\n\r\nexports=module.exports=SEIParser;"]}