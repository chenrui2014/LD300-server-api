{"version":3,"sources":["../../src/h264/golomb.js"],"names":["assert","require","ExpGolomb","data","_data","_index","_bitLength","length","size","bitsAvailable","Error","moveIndex","result","_getBits","offsetBits","offset","byte","bits","nextSize","leadingZeroCount","skipBits","skipLZ","prefix","readBits","value","readUEG","n","x","log","exports","module"],"mappings":"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","file":"golomb.js","sourcesContent":["/**\r\n * Created by Luky on 2017/8/3.\r\n */\r\n\r\nconst assert=require('assert');\r\n\r\n// Exponential-Golomb buffer decoder\r\nclass ExpGolomb {\r\n\r\n    constructor(data) {\r\n        this._data=data;\r\n        this._index=0;\r\n        this._bitLength = data.length* 8;\r\n    }\r\n\r\n    destroy(){\r\n        this._data=null;\r\n    }\r\n\r\n    get bitsAvailable() {\r\n        return this._bitLength - this._index;\r\n    }\r\n\r\n    get index(){\r\n        return this._index;\r\n    }\r\n\r\n    skipBits(size){\r\n        // console.log(`  skip bits: size=${size}, ${this._index}.`);\r\n        if (this.bitsAvailable < size) {\r\n            throw new Error('no bytes available');\r\n        }\r\n        this._index += size;\r\n    }\r\n\r\n    readBits(size,moveIndex=true) {\r\n        // console.log(`  read bits: size=${size}, ${this._index}.`);\r\n        const result = this._getBits(size, this._index,moveIndex);\r\n        // console.log(`    read bits: result=${result}`);\r\n        return result;\r\n    }\r\n\r\n    _getBits(size, offsetBits, moveIndex=true){\r\n        if (this.bitsAvailable < size) {\r\n            throw new Error('no bytes available');\r\n        }\r\n        const offset = offsetBits % 8;\r\n        const byte = this._data[(offsetBits / 8) | 0] & (0xff >>> offset);\r\n        const bits = 8 - offset;\r\n        if (bits >= size) {\r\n            if (moveIndex) {\r\n                this._index += size;\r\n            }\r\n            return byte >> (bits - size);\r\n        } else {\r\n            if (moveIndex) {\r\n                this._index += bits;\r\n            }\r\n            const nextSize = size - bits;\r\n            return (byte << nextSize) | this._getBits(nextSize, offsetBits + bits, moveIndex);\r\n        }\r\n    }\r\n\r\n    skipLZ(size) {\r\n        let leadingZeroCount=0;\r\n        for (; leadingZeroCount < this._bitLength - this._index; ++leadingZeroCount) {\r\n            if (0 !== this._getBits(1, this._index + leadingZeroCount, false)) {\r\n                //console.log(`  skip LZ  : size=${leadingZeroCount}, ${this._index}.`);\r\n                this._index += leadingZeroCount;\r\n                return leadingZeroCount;\r\n            }\r\n        }\r\n        return leadingZeroCount;\r\n    }\r\n\r\n    skipBit(){\r\n        this.skipBits(1);\r\n    }\r\n\r\n    skipByte(){\r\n        this.skipBits(8);\r\n    }\r\n\r\n    skipUEG() {\r\n        this.skipBits(1 + this.skipLZ());\r\n    }\r\n\r\n    skipSEG(){\r\n        this.skipBits(1 + this.skipLZ());\r\n    }\r\n\r\n    readUEG(){\r\n        const prefix = this.skipLZ();\r\n        return this.readBits(prefix + 1) - 1;\r\n    }\r\n\r\n    readSEG(){\r\n        const value = this.readUEG();\r\n        if (0x01 & value) {\r\n            // the number is odd if the low order bit is set\r\n            return (1 + value) >>> 1; // add 1 to make it even, and divide by 2\r\n        } else {\r\n            return -1 * (value >>> 1); // divide by two then make it negative\r\n        }\r\n    }\r\n\r\n    readBoolean() {\r\n        return 1 === this.readBits(1);\r\n    }\r\n\r\n    readUByte(){\r\n        return this.readBits(8);\r\n    }\r\n\r\n    readUShort(){\r\n        return this.readBits(16);\r\n    }\r\n\r\n    readUInt(){\r\n        return this.readBits(32);\r\n    }\r\n\r\n    readU1(){\r\n        return this.readBits(1);\r\n    }\r\n\r\n    readUN(n,moveIndex=true){\r\n        return this.readBits(n,moveIndex);\r\n    }\r\n\r\n    alignToByte(){\r\n        let n=(-this.bitsAvailable)&7;\r\n        if(n>0) this.skipBits(n);\r\n    }\r\n\r\n    /**\r\n     Calculate the log base 2 of the argument, rounded up.\r\n     Zero or negative arguments return zero\r\n     Idea from http://www.southwindsgames.com/blog/2009/01/19/fast-integer-log2-function-in-cc/\r\n     */\r\n    static intlog2(x)\r\n    {\r\n        let log = 0;\r\n        if (x < 0) { x = 0; }\r\n        while ((x >> log) > 0)\r\n        {\r\n            log++;\r\n        }\r\n        if (log > 0 && x === 1<<(log-1)) { log--; }\r\n        return log;\r\n    }\r\n}\r\n\r\nexports=module.exports=ExpGolomb;"]}