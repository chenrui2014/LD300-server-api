{"version":3,"sources":["../../src/h264/h264_pps_parser.js"],"names":["Util","require","ExpGolomb","SPSParser","assert","PPSParser","nalu","SPSTable","rbsp","ebsp2rbsp","gb","skipByte","ret","pps_id","readUEG","sps_id","skipBit","pic_order_present_flag","readBoolean","num_slice_groups_minus1","console","error","run_length_minus1","top_left","bottom_right","slice_group_map_type","i_group","slice_group_change_direction_flag","readBits","slice_group_change_rate_minus1","slice_group_id","pic_size_in_map_units_minus1","i","readUN","intlog2","ref_count","ok","weighted_pred_flag","weighted_bipred_idc","skipSEG","skipBits","redundant_pic_cnt_present_flag","exports","module"],"mappings":"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","file":"h264_pps_parser.js","sourcesContent":["/**\r\n * Created by Luky on 2017/8/3.\r\n */\r\n\r\nconst Util=require('./h264_util');\r\nconst ExpGolomb=require('./golomb');\r\nconst SPSParser=require('./h264_sps_parser');\r\nconst assert=require('assert');\r\n\r\nclass PPSParser{\r\n    static parsePPS(nalu,SPSTable){\r\n        let rbsp = Util.ebsp2rbsp(nalu);\r\n        let gb = new ExpGolomb(rbsp);\r\n\r\n        gb.skipByte();\r\n        let ret={};\r\n        ret.pps_id= gb.readUEG();\r\n        ret.sps_id=gb.readUEG();//seq_parameter_set_id\r\n        gb.skipBit();//entropy_coding_mode_flag\r\n        ret.pic_order_present_flag=gb.readBoolean();\r\n        ret.num_slice_groups_minus1=gb.readUEG();\r\n\r\n        if(ret.num_slice_groups_minus1 > 0 )\r\n        {\r\n            console.error('FMO不受支持');\r\n            ret.run_length_minus1=[];\r\n            ret.top_left=[];\r\n            ret.bottom_right=[];\r\n            let slice_group_map_type =ret.slice_group_map_type = gb.readUEG();\r\n            if( slice_group_map_type === 0 )\r\n            {\r\n                for(let i_group = 0; i_group <= ret.num_slice_groups_minus1; i_group++ )\r\n                {\r\n                    ret.run_length_minus1[ i_group ] = gb.readUEG();\r\n                }\r\n            }\r\n            else if( slice_group_map_type === 2 )\r\n            {\r\n                for(let i_group = 0; i_group < ret.num_slice_groups_minus1; i_group++ )\r\n                {\r\n                    ret.top_left[ i_group ] = gb.readUEG();\r\n                    ret.bottom_right[ i_group ] = gb.readUEG();\r\n                }\r\n            }\r\n            else if( slice_group_map_type === 3\r\n                ||slice_group_map_type === 4 \r\n                ||slice_group_map_type === 5 )\r\n            {\r\n                ret.slice_group_change_direction_flag = gb.readBits(1);\r\n                ret.slice_group_change_rate_minus1 = gb.readUEG();\r\n            }\r\n            else if( slice_group_map_type === 6 )\r\n            {\r\n                ret.slice_group_id=[];\r\n                ret.pic_size_in_map_units_minus1 = gb.readUEG();\r\n                for(let i = 0; i <= ret.pic_size_in_map_units_minus1; i++ )\r\n                {\r\n                    ret.slice_group_id[ i ] = gb.readUN(ExpGolomb.intlog2(ret.num_slice_groups_minus1+1)); // was u(v)\r\n                }\r\n            }\r\n        }\r\n        //num_ref_idx_l0_active_minus1,num_ref_idx_l1_active_minus1\r\n        ret.ref_count=[gb.readUEG()+1,gb.readUEG()+1];\r\n        assert.ok(ret.ref_count[0]-1<=32-1&&ret.ref_count[1]-1<=32-1);\r\n        ret.weighted_pred_flag = gb.readBits(1);\r\n        ret.weighted_bipred_idc = gb.readUN(2);\r\n        gb.skipSEG();//pic_init_qp_minus26\r\n        gb.skipSEG();//pic_init_qs_minus26\r\n        gb.skipSEG();//chroma_qp_index_offset\r\n        gb.skipBits(2);//deblocking_filter_control_present_flag,constrained_intra_pred_flag\r\n        ret.redundant_pic_cnt_present_flag = gb.readBits(1);\r\n\r\n/*        ret.more_rbsp_data_present =PPSParser.moreRBSPData(gb)===1;\r\n        if(ret.more_rbsp_data_present )\r\n        {\r\n            ret.transform_8x8_mode_flag = gb.readBoolean();\r\n            ret.pic_scaling_matrix_present_flag = gb.readBoolean();\r\n            ret.pic_scaling_list_present_flag=[];\r\n            if(ret.pic_scaling_matrix_present_flag )\r\n            {\r\n                for(let i = 0; i < 6 + 2* ret.transform_8x8_mode_flag; i++ )\r\n                {\r\n                    ret.pic_scaling_list_present_flag[ i ] = gb.readBoolean(1);\r\n                    /!*ret.ScalingList4x4=[];\r\n                    ret.UseDefaultScalingMatrix4x4Flag=[];*!/\r\n                    if(ret.pic_scaling_list_present_flag[ i ] )\r\n                    {\r\n                        if( i < 6 )\r\n                        {\r\n                            SPSParser._skipScalingList(gb, 16);\r\n                        }\r\n                        else\r\n                        {\r\n                            SPSParser._skipScalingList(gb,64);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            ret.second_chroma_qp_index_offset = gb.readSEG();\r\n        }*/\r\n        return ret;\r\n    }\r\n\r\n/*    static moreRBSPData(gb)\r\n    {\r\n        if ( !gb.bitsAvailable) { return 0; }\r\n        if ( gb.readBits(1,false)===1) { return 0; } // if next bit is 1, we've reached the stop bit\r\n        return 1;\r\n    }\r\n\r\n    static skipRBSPTrailingBits(gb){\r\n        assert.ok(gb.readBoolean());//rbsp_stop_one_bit\r\n        while(gb.bitsAvailable!==8)\r\n        {\r\n            assert.ok(!gb.readBoolean());//rbsp_alignment_zero_bit equal to 0\r\n        }\r\n    }*/\r\n}\r\n\r\nexports=module.exports=PPSParser;\r\n"]}